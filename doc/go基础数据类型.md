### 数据类型 ###

所有数据在底层上都是由比特组成,但是通过语言封装数据类型,可以兼顾硬件的特性和表达赋值数据的便捷性;

go将数据类型分为四类:基础类型,复合类型,引用类型和接口类型.

基础类型:数值,字符串,布尔型;    
复合类型:数组,结构体     
引用类型:指针,切片,字典,函数,通道    
接口类型:接口

#### 基础类型 ####

- 整型

数值类型包括:几种不同大小的整数,浮点数,复数.每种数值类型都决定了内存占用和是否支持正负符号.

整型数据类型:int8,int16,int32,int64(有符号);uint8,uint16,uint32,uint64(无符号)

Unicode字符rune类型==int32,通常用于表示一个Unicode码点;    
byte==uint8类型,一般强调数值时一个原始数据而不是小整数;    
uintptr:无符号整数类型,未指定具体的bit大小但足以容纳指针;    

不管它们的具体大小,int,uint,uintprt是不同类型的兄弟类型,同时使用时需要显示类型转换;

下面时关于算术运算,逻辑运算,比较运算的二元运算符,按优先级递减排序:    

```
*      /      %      <<       >>     &       &^
+      -      |      ^
==     !=     <      <=       >      >=
&&
||
```

使用括号可以提高优先级.

算术运算符+-*/可以适用于整数,浮点数,复数,但取模运算符%仅用于整数    

如果实际存储数据超过分配大小,会造成数据溢出,超出高位的bit位部分将被丢弃.

位操作运算符:

```
&      位运算 AND
|      位运算 OR
^      位运算 XOR
&^     位清空（AND NOT）
<<     左移
>>     右移
```
其中^是按位取反;&^是按位清空,x&^y:如果y为1,则位结果为0,如果y=0,则结果为等于x;

类型转换基础是相同的底层数据结构,转换只改变占空间大小,这就意味着大类型转小类型会造成改变数值或丢失精度.

- 浮点数

go有两种浮点数:float32,float64.

- 复数

包含两种精度的复数类型:complex64,complex128,分别对应float32,float64;内置的complex函数用于构建复数,内建的real,imag函数分别返回复数的实部和虚部;

复数的值=RE + IMi.RE:实数部分;IM:虚数部分;i:虚数单位;RE,IM均为float类型;

复数声明语法:var name complex128 = complex(x, y)

name:复数变量名;complex128:复数类型;complex是go的内置函数用于为复数赋值;x,y分别表示构成该复数float64类型的数值,x为实部,y为虚部;

- 布尔型

有两个值:true,false;

&&,||用于条件连接,同时还具备短路行为.&&优先级高于||;

- 字符串

字符串是一个不可改变的字节序列,可以包含任意数据,但通常是人类可读的文本.文本字符串通常是采用UTF8编码的Unicode码点(rune)序列.

空间占用:ASCII字符占用一个字节,其他的要占用两个或多个字节;

字符串是不可变的,你不能直接替换原本字符串中的部分数据.不变性意味着两个字符串共享相同的底层数据的话也是安全的,这也使得任意长度的字符串使用成本比较低,子集和父集可以共享一个字符串.

字符串使用特殊字符:

```
转义方式
\a      响铃
\b      退格
\f      换页
\n      换行
\r      回车
\t      制表符
\v      垂直制表符
\'      单引号（只用在 '\'' 形式的rune符号面值中）
\"      双引号（只用在 "..." 形式的字符串面值中）
\\      反斜杠
```

特殊字符使用还可以通过进制转换获取:

```
十六进制:\xhh    
八进制: \ooo
```

还可以通过:反引号``进行原样输出来使用特殊字符.


Unicode码点:

由于互联网从美国走向了全球,原来的ASCII只包含了英文的文本无法满足其他语言的文本需求,所以就进行了文本扩充,来实现网络文本的跨地区适配.

UTF8

UTF8是将Unicode编码为字节序列的变长编码.它使用1到4字节来表示每个Unicode码点,ASCII部分字符只使用一个字节,常用字符部分使用2或3字节表示.每个符号编码后第一个字节的高端bit位用于表示编码总共有多少个字节.

```
0xxxxxxx                             runes 0-127    (ASCII)
110xxxxx 10xxxxxx                    128-2047       (values <128 unused)
1110xxxx 10xxxxxx 10xxxxxx           2048-65535     (values <2048 unused)
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx  65536-0x10ffff (other values unused)
```

常用字符串库:bytes,strings,strconv,unicode包

strings:字符串查询,替换,比较,截断,拆分和合并等功能;    
bytes:字符串分配和复制    
strconv:布尔型,整型数,浮点数和字符串转换    
unicode:提供rune字符相关功能函数,如区分字符数字,字母大小写转换等.


- 常量

常量是运行期间不会变化的量,它的值在编译期计算.可以防止在运行期被意外或恶意修改.

常量的赋值和变量声明类似,常量的声明语句定义了:常量标识,常量名,类型和值;每种常量的潜在类型都是基础类型:boolean,string或数值;

```
	const pi = 3.14159
	// 多个常量定义
	const (
		e = 2.718
		pi = 3.14159
	)
```

常量的运算在编译期完成,减少了运行期工作,编译提前发现问题,也便于编译优化.    
常量间的所有算数运算,逻辑运算,比较运算的结果也是常量,对常量的类型转换或以下函数调用返回的也是常量结果:

```
len,cap,real,imag,complex,unsafe.Sizeof
```

未指明类型的常量,会自动进行类型推定;批量常量声明,可以通过前一个常量的定义值,进行值传递

iota常量生成器

它用于生成一组相似规则初始化的常量,但是不用每行都写一遍初始化表达式.在一个const声明语句中,在第一个声明的常量所在行,iota将会被置为0,然后每个后续常量声明进行加一;

```
type Weekday int

const (
    Sunday Weekday = iota //0
    Monday				  //1
    Tuesday				  //2
    Wednesday
    Thursday
    Friday
    Saturday
)

```

无类型常量

go的常量可以分为有类型常量和无类型常量,无类型常量可以提供更高精度的算术运算和直接用于多种表达式而不用显示类型转换.    
无类型常量可以分为:无类型布尔型,无类型整数,无类型字符,无类型浮点数,无类型复数,无类型字符串    

```
var x float32 = math.Pi
var y float64 = math.Pi
var z complex128 = math.Pi
```

如果已经将无类型变量赋值给特定类型变量,其他类型使用时就要进行类型转换(显示或隐式);    
只有常量可以是无类型的.变量没有显示类型声明时,常量的形式将隐式决定变量的类型;    
无类型整数常量转为int,它的内存大小是不确定的,但无类型浮点数和复数常量则转换未内存大小明确的float64,complex128.这是因为如果不知道浮点数的内存大小河南写出正确的数值算法.    





















