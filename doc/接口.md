### 接口 ###

接口类型是对于其他类型行为的抽象;因为接口类型通过只声明不定义具体实现细节,来增加函数的灵活性和扩展性;    
go中接口类型可以进行隐式实现,即具体实现中不需要定义所有接口声明的函数,只需要按需使用即可.这种定义方式可以让你修改接口时,不用改变已有实现;

#### 接口约定 ####

通过接口约定可以增加函数的灵活性.你不用每次都定义具体的结构和操作集,只通过方法定义即可明确可以通过它实现的功能.不定义具体结构,只是接口的约定的方式可以灵活的实现里氏替换;

	func Fprintf(w io.Writer, format string, args ...interface{}) (int, error)
	func Printf(format string, args ...interface{}) (int, error) {
	    return Fprintf(os.Stdout, format, args...)
	}
	func Sprintf(format string, args ...interface{}) string {
	    var buf bytes.Buffer
	    Fprintf(&buf, format, args...)
	    return buf.String()
	}
	
	// Writer接口定义
	package io
	type Writer interface {
	    Write(p []byte) (n int, err error)
	}

因为os.Stdout和&buf满足Writer接口约定,所以可以使用Fprintf函数.


#### 接口类型 ####

接口类型定义了具体的方法集合,而实现方法的具体类型是这个接口类型的实例;    

	package io
	type Reader interface {
	    Read(p []byte) (n int, err error)
	}


接口还可以通过组合方式进行扩展
	
	type ReadWriter interface {
	    Reader
	    Writer
	}

#### 接口实现 ####

实现:一个类型拥有一个接口所有的方法.这意味着:表达一个类型属于某个接口只要实现该接口即可.

	var w io.Writer
	w = os.Stdout 

如果具体类型T,它的方法接收器的类型可以是T或\*T的指针.在T上调用\*T是合法的,因为编译器隐式的获取了它的地址.但这仅仅是一个语法糖,T类型不拥有\*T指针的方法.

接口可以封装和隐藏具体实现类型及其值,只有接口中暴露的方法可以被调用到:

	os.Stdout.Close() // OK: *os.File has Close method
	
	var w io.Writer
	w = os.Stdout
	w.Close()  // compile error: io.Writer lacks Close method

空接口类型:interface{}.空接口类型没有实现类型要求,它可以接收任意值,也因此不能直接对它持有值做操作.

go的接口不需要显示定义,在你需要的时候定义一个新的抽象或特定特点的组,而不需要修改具体类型的定义.因为你只要包含该接口的所有方法即意味着实现该接口,所以接口通过隐式实现很灵活.

