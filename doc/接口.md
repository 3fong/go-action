### 接口 ###

接口类型是对于其他类型行为的抽象;因为接口类型通过只声明不定义具体实现细节,来增加函数的灵活性和扩展性;    
go中接口类型可以进行隐式实现,即具体实现中不需要定义所有接口声明的函数,只需要按需使用即可.这种定义方式可以让你修改接口时,不用改变已有实现;

#### 接口约定 ####

通过接口约定可以增加函数的灵活性.你不用每次都定义具体的结构和操作集,只通过方法定义即可明确可以通过它实现的功能.不定义具体结构,只是接口的约定的方式可以灵活的实现里氏替换;

	func Fprintf(w io.Writer, format string, args ...interface{}) (int, error)
	func Printf(format string, args ...interface{}) (int, error) {
	    return Fprintf(os.Stdout, format, args...)
	}
	func Sprintf(format string, args ...interface{}) string {
	    var buf bytes.Buffer
	    Fprintf(&buf, format, args...)
	    return buf.String()
	}
	
	// Writer接口定义
	package io
	type Writer interface {
	    Write(p []byte) (n int, err error)
	}

因为os.Stdout和&buf满足Writer接口约定,所以可以使用Fprintf函数.


#### 接口类型 ####

接口类型定义了具体的方法集合,而实现方法的具体类型是这个接口类型的实例;    

	package io
	type Reader interface {
	    Read(p []byte) (n int, err error)
	}


接口还可以通过组合方式进行扩展
	
	type ReadWriter interface {
	    Reader
	    Writer
	}










