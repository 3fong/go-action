### 并发 ###

并发机制,多goroutine间的共享变量,并发问题的分析手段,解决模式,goroutine和线程区别

#### 竞争条件 ####

并发:无法判断多个事件执行的顺序的情形;     
并发安全:函数,方法,类型在线性执行或并发执行时,都能正确的返回结果;    
**包级别的导出函数一般都是并发安全的.**因为只要让变量不在多个goroutine内共享,它就一定是并发安全的;但是如果存在共享变量,就必须维护一个更高层的互斥不变量来保证其访问的安全性;   
并发的影响有很多:如死锁(deadlock),活锁(livelock),饿死(resource starvation),竞争条件等

竞争条件:程序在多个goroutine交叉执行操作时,没有给出正确的结果;因为竞争条件的发生存在偶发性,所以发现和排查都比较困难,它会真实的对业务造成影响;     
实际竞争条件就是我们常说的脏数据,并发执行业务逻辑存在数据过程中显示不准确甚至由于结果覆盖造成总体数据缺失的问题;    
比较典型的就是汇款问题:

	a,b同时向账户汇款,入账语句:balance=balance+amount.并发下的过程和结果可能有四种:
	1. a先入账100,b再入账200,结果300
	2. b先入账200,a再入账200,结果300
	3. a或b同时入账,最终a覆盖了b的结果,结果为100
	3. a或b同时入账,最终b覆盖了a的结果,结果为200

因为实际的入账语句非原子性操作,执行时就存在被拆分执行的可能,造成竞争条件;     
数据竞争:两个以上的goroutine并发访问相同的变量且至少其中一个为写操作时发生的竞争条件;数据竞争是一种特定的竞争条件,是由于写入数据造成的数据异常;    
三种避免数据竞争的方式:

	1. 不写.只读是并发安全的,因为不会涉及到数据不一致;共享变量可以通过全局变量的方式来初始化,避免写操作;
	2. 只用一个goroutine访问变量.避免并发的发生,顺序执行不涉及同时修改数据,可以避免写竞争;单一协程写操作,通过channel来传值
	3. 互斥条件.多goroutine访问时,一次只能一个goroutine操作.这是常规的加锁方式;

#### sync.Mutex互斥锁 ####

保证最多只有一个goroutine在同一时刻访问共享变量.    
重入锁:同一线程如果持有锁后可以再次获取其他锁,因为同一线程不涉及变量共享问题,通过锁计数来避免持有多锁时的锁释放问题.它主要用于解决持有锁后再次获取锁时发生死锁问题.    
go中没有重入锁.因为mutex的目的是确保共享变量在程序执行时的关键点上保证不变性(持有锁操作共享变量会打破不变性,引入重入代表了可以在另一个锁范围内操作共享变量,这也意味着该变量可以是另一个锁范围的变量,这样就打破了锁范围内变量被唯一修改的限制),所以应该减少锁定时间及锁数量.多个锁也容易造成bug.    
重入锁的实现跟底层结构有直接关系:    
其实java采用重入锁的原因是线程和主机的操作系统线程是一对一,锁和变量共享直接便捷.    
但是go是多个协程对应操作系统一个线程,通过runtime来进行通信,所以线程同步会比较复杂.
它本身设计推荐通道,消息来进行通信,不想通过复杂的实现来保证重入锁.    
所以正确的做法应该时拆分函数,分解不同锁.

	// 重入锁
     func F() {
         mu.Lock()
         ... do some stuff ...
         G()
         ... do some more stuff ...
         mu.Unlock()
     }

     func G() {
         mu.Lock()
         ... do some stuff ...
         mu.Unlock()
     }

F()中已经有锁,但是又引用了G(),G中也有锁,就形成了单一线程同时拥有多把锁的情况.G中可能会修改F()中的变量,打破共享变量的不变性,可能引起bug;    

	//修正
     func F() {
         mu.Lock()
         ... do some stuff ...
         g()
         ... do some more stuff ...
         mu.Unlock()
     }
	// 内部私有
	 func g() {
         ... do some stuff ...
     }
	// 对外使用
     func G() {
         mu.Lock()
         g()
         mu.Unlock()
     }

同时提供内外两个函数,g()用于内部使用,不进行锁控制,G()用于外部调用,通过锁保证原子性操作,通过这种方式避免重入锁问题


#### sync.RWMutex读写锁 ####

多读单写锁:允许多个只读操作并行执行,写操作互斥.适用于读多写少的情形.go中通过sync.RWMutex来实现.

	var mu sync.RWMutex
	var balance int
	func Balance() int {
	    mu.RLock() // readers lock
	    defer mu.RUnlock()
	    return balance
	}

RLock和RUlock用于获取和释放读取或共享锁;上面mu.Lock和mu.Unlock来获取和释放一个写或互斥锁;RWMutex内部记录更复杂,它比mutex慢.


