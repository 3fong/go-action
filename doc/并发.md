### 并发 ###

并发机制,多goroutine间的共享变量,并发问题的分析手段,解决模式,goroutine和线程区别

#### 竞争条件 ####

并发:无法判断多个事件执行的顺序的情形;     
并发安全:函数,方法,类型在线性执行或并发执行时,都能正确的返回结果;    
**包级别的导出函数一般都是并发安全的.**因为只要让变量不在多个goroutine内共享,它就一定是并发安全的;但是如果存在共享变量,就必须维护一个更高层的互斥不变量来保证其访问的安全性;   
并发的影响有很多:如死锁(deadlock),活锁(livelock),饿死(resource starvation),竞争条件等

竞争条件:程序在多个goroutine交叉执行操作时,没有给出正确的结果;因为竞争条件的发生存在偶发性,所以发现和排查都比较困难,它会真实的对业务造成影响;     
实际竞争条件就是我们常说的脏数据,并发执行业务逻辑存在数据过程中显示不准确甚至由于结果覆盖造成总体数据缺失的问题;    
比较典型的就是汇款问题:

	a,b同时向账户汇款,入账语句:balance=balance+amount.并发下的过程和结果可能有四种:
	1. a先入账100,b再入账200,结果300
	2. b先入账200,a再入账200,结果300
	3. a或b同时入账,最终a覆盖了b的结果,结果为100
	3. a或b同时入账,最终b覆盖了a的结果,结果为200

因为实际的入账语句非原子性操作,执行时就存在被拆分执行的可能,造成竞争条件;     
数据竞争:两个以上的goroutine并发访问相同的变量且至少其中一个为写操作时发生的竞争条件;数据竞争是一种特定的竞争条件,是由于写入数据造成的数据异常;    
三种避免数据竞争的方式:

	1. 不写.只读是并发安全的,因为不会涉及到数据不一致;共享变量可以通过全局变量的方式来初始化,避免写操作;
	2. 只用一个goroutine访问变量.避免并发的发生,顺序执行不涉及同时修改数据,可以避免写竞争;单一协程写操作,通过channel来传值
	3. 互斥条件.多goroutine访问时,一次只能一个goroutine操作.这是常规的加锁方式;




